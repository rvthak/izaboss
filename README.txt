 Εργασια Μαθηματος - Αντικειμενοστραφης Προγραμματισμος 2019-2020
 
 Μέλη ομάδας:
	Γιώργος Γαλάνης,   ΑΜ:1115201800024
	Γιάννης Ροβιθάκης, ΑΜ:1115201800164

// The program was Developed on pop!_os 19.10 64-bit
// The compiler used during development is g++


 => For simplicity we chose to build the program using a makefile
> Compile the program using command:
make

> Debug the program using commands:
make gdb 	// for gdb
make vg		// for valgrind
( There are more sophisticated options available for memory leaks, read the makefile itself )

> Clean the object files with:
make clean

> Run the program with:
./l5r


> Μεθοδολογια εκπονησης/οργανωσης/συνεργασιας:

Επιλεξουμε να δουλεψουμε μεσω github σε ενα private repository για να μπορουμε ευκολα να συνεργαζομαστε 
απο αποσταση σε κοινα αρχεια ενω παραλληλα διατηρουμε version control για ασφαλεια και αξιοπιστια.
Ταυτοχρονα μπορεσαμε να οργανωσουμε τα προβληματα και τους στοχους μας δημιουργωντας issues 
για καλυτερη οργανωση.

Απο την αρχη του προτζεκτ προσπαθησαμε να σχεδιασουμε την δομη του οσο καλυτερα μπορουσαμε με την
κατανοηση του προβληματος που ειχαμε και τις απαιτησεις της εκφωνησης. Προσπαθησαμε να το σπασουμε
σε οσο γινεται λογικες εννοτητες με διαχειρισιμου μεγεθους αρχεια και να τα σχεδιασουμε ωστε να
λειτυργουν ως ανεξαρτητα συστηματα μεταξυ τους ωστε να ειναι πιο ευκολο το development καθως και
το debugging. Μοιρασαμε μεταξυ μας τα αρχεια, τα υλοποιησαμε ανεξαρτητα και τα συνενωσαμε.


> Σημαντικα Γενικα Σχολια:

1. Εφοσον επιλεξαμε να υλοποιησουμε διαδικασια παιξιματος του παιχνιδιου, αποφασισαμε να προσθεσουμε
στο προγραμμα μερικα quality of life features ωστε να κανουν το παιχνιδι πιο ευκολο και ευχαριστο.
Δημιουργησαμε ενα βασικο console UI system το οποιο χρησιμοποιει κλησεις του λειτουργικου συστηματος
για να καθαριζει οποτε χρειαζεται την οθονη και να αφηνει τον χρηστη να βλεπει μια καθαρη και 
οργανωμενη οθονη. (Το συστημα UI ειναι cross platform με windows αφου κατα την μεταγλώττιση, ο
προεπεξεργαστης εντοπιζει μεσω defines το λειτουργικο συστημα και κανει τις απαραιτητες αλλαγες).
Μπορειτε αμα επιθυμειτε να απενεργοποιησετε πληρως το UI κανοντας comment το define του στο αρχειο
ui.hpp και μεταγλωτιζοντας το προγραμμα ξανα αφου πριν εχετε τρεξει μια φορα την εντολη make clean

2. Παραλληλα επιλεξαμε να προσθεσουμε στο παιχνιδι μερικες εικονες Ascii Art απο την σελιδα 
https://www.asciiart.eu/ για να κανουμε το παιχνιδι ακομα πιο ευχαριστο και ζωντανο.
(Συμπεριλαβαμε τα ονοματα των δημιουργων).

3. Ακομα, τοσο το ονομα του παιχνιδιου οσο και τα ονοματα των φασεων ειναι γραμμενα και σε ιαπωνικα.
Προσπαθησαμε να δωσουμε οσο περισσοτερο χαρακτηρα γινεται στο παιχνιδι.

4. Οι ακριβεις λετομερειες υλοποιησης καθως και οι αποφασεις που πηραμε ειναι παρα πολλες για να 
συμπεριληφθουν ολες στο παρον αρχειο αλλα θα προσπαθησουμε να παραθεσουμε οσο πιο πολλες πληροφοριες
γινεται χωρις να γινουμε κουραστικοι.

5. Επιλεξαμε το παιχνιδι να παιζεται με εισοδο του χρηστη. Οι τροποι που ζητειται εισοδος ειναι οι εξεις:
	1) Αριθμος σε μια ζητουμενη εμβελεια		Number in [1, n]
	2) θετικη/αρνητικη απαντηση σε ερωτημα		(y/n)
	3) Να πατηθει το πληκτρο enter οταν το παιχνιδι βρισκεται σε waiting state

6. Το παιχνιδι δουλευει κανονικα με οσους παικτες και να επιλεγουν απο τον χρηστη. Μονο που δεν εχουμε
προσθεσει μηνυμα στην οθονη οταν ενας απο τους παικτες βγει απο το παιχνιδι, απλα δεν τυπωνονται οι οθονες του
πλεον δηλαδη βγαινει απο το παιχνιδι. (Για να αλλαξετε τον αριθμο παικτων αλλαξτε τον αριθμο παικτων στο 
define στην αρχη της main.)

7. Τα βοηθητικα αρχεια που δωθηκαν χρησιμοποιουνται σχεδον ανεπαφα και δεν χρησιμοποιησαμε 
πουθενα το προτεινομενο enum.

8. Σε καποια σημεια βολευε και χρησιμοποιησαμε καποιες απο τις βιβλιοθηκες της C (παλιες συνηθειες)

9. Εχουμε προσθεσει σχολια σε ολα τα header files ωστε να κανουμε την κατανοηση των συναρτησεων 
μας πιο ευκολη στον αναγνωστη


>Πληροφορίες σχετικά με την μεθοδολογία υλοποιησης: (Οπου θεωρουμε οτι χρειαζονται διευκρινησεις)

1. Gameboard:
-Η υλοποιηση μας απαιτει πριν κληθει οποιαδηποτε αλλη συναρτηση της κλασης να κληθει η initializeGameBoard
-Εφοσον η τιμη των παικτων δεν αλλαζει κατα την διαρκεια του παιχνιδιου επιλεξαμε να δωσουμε αρχικη τιμη
στους παικτες μεσω ενος στατικου μετρητη κατα την δημιουργια των οχυρων τους και στην συνεχεια καναμε
μια φορα sort τον πινακα με τους παικτες. (Δεν ειναι απαραιτητο ετσι το sort απλα ειναι καλο για την 
περιπτωση αλλαγης υλοποιησης μεθοδου αποκτησης τιμης).
-Βαλαμε την printGameStatistics να τυπωνει τα στατιστικα που θεωρησαμε πιο χρησιμα και ενδιαφεροντα
-Η gameplay σε βαζει σε ενα ατερμωνο loop το οποιο διακοπτεται μονο εαν καποιος παικτης κατα το 
battlePhase καταφερει να ικανοποιησει τις προϋποθεσεις της checkWinningCondition

2. Battle phase:
- Δινεται η δυνατοτητα στον παικτη να κανει στην αρχη του γυρου απο μονος του tap οσον απο τον
στατο του επιθυμει, και να τους αφαιρεσει ετσι ολοκληρωτικα απο το πεδιο της μαχης, διασφαλιζοντας
την ασφαλεια τους (Δινουμε ετσι μια επιπλεον δυνατοτητα στρατηγικης κινησης).
(Μονο οι untapped καρτες μπορουν να επιτεθουν/αμυνθουν συνεπως και να πεθανουν)
- Τα αντικειμενα και οι ακολουθοι μιας προσωπικοτητας δεν γινονται ποτε tap αφου το tap στην
προσωπικότητα τους ειναι αρκετο για να τα απενεργοποιησει προσωρινα.
- Επιλεξαμε τα αντικειμενα, οι ακολουθοι καθως και οι προσωπικοτητες, οταν συμφωνα με καποιο 
κανονα βγουν απο το παιχνιδι, να καταστρεφονται ολοκληρωτικα. (Εναλλακτικα θα μπορουσαμε να 
υλοποιησουμε μια λιστα απο cards graveyard στον καθε παικτη, να τις περναμε εκει και να τις 
αποδεσμευσουμε ολες μαζι στο τελος, αλλα δεν ειδαμε κανενα οφελος απο το παραπανω)
-Ο στρατος του παικτη χωριζεται σε 3 λογικες ομαδες:
	1) Τις tapped καρτες στο army list του τις οποιες εχει επιλεξει να προστατεψει και ειναι inactive
	2) Τις untapped καρτες στο  army list του οι οποιες ειναι η αμυντικη του δυναμη
	3) Τις καρτες που βρισκονται στο attack force του με τις οποιες μπορει να επιτεθει
(Στο τελος της φασης αν/οσοι απο το attack force εχουν επιζησει επιστρεφουν tapped στο army)
- Επιλεξαμε καθε παικτης να μπορει να κανει μια μονο επιθεση στην φαση μαχης.

3. Holding:
- Τα holdings βρισκονται στη λιστα holdings του παικτη και η αλυσιδα σχηματιζεται πανω στα holdings
(= τα upper/lower holdings δεν βρισκονται στη λιστα, αλλα ειναι attached στα μελη της)
- Καθε φορα που γινεται αγορα ενος holding απο τον παικτη, ελεγχουμε αν ειναι δυνατη η δημιουργια
βελτιστης αλυσιδας. Αν βρεθει, τοτε το holding προσκολαται κατευθειαν πανω στο καταλληλο
holding αλλιως μπαινει και αυτη στο list με τα holdings.
- Εχουμε προσθεσει μια μεταβλητη isMine η οποια προσδιοριζει αν μια καρτα ειναι ορυχειο + τι τυπος 
ορυχειου ειναι (0=not mine, 1=mine, 2=gold, 3=crystal)
- Παιρνοντας περιπτώσεις για τους τρείς τύπους mine, ψάχνουμε την βέλτιστη δυνατή
αλυσίδα που μεγιστοποιει το κέρδος του παικτη.
-Ως καλύτερη αλυσίδα, ορίσαμε το full chain. Αν δεν βρεθεί, παίρνουμε την επόμενη λύση που είναι η σύνδεση του
μολις αγορασμενου holding σε ενα που ηδη βρισκεται στη λιστα (Τυχαια επιλογη εδω)
- Αξίζει να τονιστεί ότι κατα την συνδεση οποιουδηποτε holding με gold mine εξασφαλιζουμε οτι το gold mine 
ειναι αυτο που βρισκεται στην λιστα των holdings για ευκολοτερη μελλοντικη ολοκληρωση αλυσιδας.

4. Player:
-Πολλες αλλα απλες συναρτησεις σχετικα χαμηλου αφαιρετικου επιπεδου. Προτεινουμε να διαβασετε τα σχολια στο
header file, ειναι επαρκη για την κατανοηση της λειτουργικοτητας.

// Στην περιπτωση που παραλειψαμε να αναγερουμε κατι σημαντικο, εντοπισετε bugs, ή εχετε ιδεες και προτασεις 
// για βελτιωση του προγραμματος μην διστασετε να επικοινωνησετε μαζι μας στο sdi1800164@di.uoa.gr
